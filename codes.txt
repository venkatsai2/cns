erri puka 

dsa, sha, des, rsa, deffie, elgamal, aes->aesheaders


//dsa 
#include <bits/stdc++.h>
#include <gmp.h>

using namespace std;


string msg, hex_msg;
vector<string> w;

vector<string> k = {
    "428a2f98d728ae22", "7137449123ef65cd", "b5c0fbcfec4d3b2f", "e9b5dba58189dbbc",
    "3956c25bf348b538", "59f111f1b605d019", "923f82a4af194f9b", "ab1c5ed5da6d8118",
    "d807aa98a3030242", "12835b0145706fbe", "243185be4ee4b28c", "550c7dc3d5ffb4e2",
    "72be5d74f27b896f", "80deb1fe3b1696b1", "9bdc06a725c71235", "c19bf174cf692694",
    "e49b69c19ef14ad2", "efbe4786384f25e3", "0fc19dc68b8cd5b5", "240ca1cc77ac9c65",
    "2de92c6f592b0275", "4a7484aa6ea6e483", "5cb0a9dcbd41fbd4", "76f988da831153b5",
    "983e5152ee66dfab", "a831c66d2db43210", "b00327c898fb213f", "bf597fc7beef0ee4",
    "c6e00bf33da88fc2", "d5a79147930aa725", "06ca6351e003826f", "142929670a0e6e70",
    "27b70a8546d22ffc", "2e1b21385c26c926", "4d2c6dfc5ac42aed", "53380d139d95b3df",
    "650a73548baf63de", "766a0abb3c77b2a8", "81c2c92e47edaee6", "92722c851482353b",
    "a2bfe8a14cf10364", "a81a664bbc423001", "c24b8b70d0f89791", "c76c51a30654be30",
    "d192e819d6ef5218", "d69906245565a910", "f40e35855771202a", "106aa07032bbd1b8",
    "19a4c116b8d2d0c8", "1e376c085141ab53", "2748774cdf8eeb99", "34b0bcb5e19b48a8",
    "391c0cb3c5c95a63", "4ed8aa4ae3418acb", "5b9cca4f7763e373", "682e6ff3d6b2b8a3",
    "748f82ee5defb2fc", "78a5636f43172f60", "84c87814a1f0ab72", "8cc702081a6439ec",
    "90befffa23631e28", "a4506cebde82bde9", "bef9a3f7b2c67915", "c67178f2e372532b",
    "ca273eceea26619c", "d186b8c721c0c207", "eada7dd6cde0eb1e", "f57d4f7fee6ed178",
    "06f067aa72176fba", "0a637dc5a2c898a6", "113f9804bef90dae", "1b710b35131c471b",
    "28db77f523047d84", "32caab7b40c72493", "3c9ebe0a15c9bebc", "431d67c49c100d4c",
    "4cc5d4becb3e42b6", "597f299cfc657e2a", "5fcb6fab3ad6faec", "6c44198c4a475817"
    
};


vector<string> H = {
    "6a09e667f3bcc908", "bb67ae8584caa73b", "3c6ef372fe94f82b", "a54ff53a5f1d36f1", 
    "510e527fade682d1", "9b05688c2b3e6c1f", "1f83d9abfb41bd6b", "5be0cd19137e2179"
};


string get_str_to_hex(string str) {
    string ans = "";
    for (int i = 0; i < str.length(); i++) {
        stringstream ss;
        ss << hex << (int)(str[i]);
        string temp;
        ss >> temp;
        ans += temp;
    }
    return ans;
}


string hex_to_binary(string str) {
    string ans = "";
    for (int i = 0; i < str.length(); i++) {
        int num = ((str[i] >= '0' && str[i] <= '9') ? (str[i] - '0') : (str[i] - 'a' + 10));
        string temp = "";
        for (int j = 0; j < 4; j++) {
            if (num % 2)
                temp = "1" + temp;
            else
                temp = "0" + temp;
            num /= 2;
        }
        ans += temp;
    }
    return ans;
}

string binary_to_hex(string str) {
    string ans = "";
    for (int i = 0; i < str.length(); i += 4) {
        int val = 0;
        for (int j = 0; j < 4; j++) {
            int temp = (str[i + j] == '1' ? 1 : 0);
            val = (val * 2) + temp;
        }
        char ch;
        if (val <= 9)
            ch = '0' + val;
        else
            ch = 'a' + (val - 10);
        ans += ch;
    }
    return ans;
}

string get_Message(string msg) {
    hex_msg = get_str_to_hex(msg);

    int bit_length = msg.length() * 8;

    int bit_length_mod = bit_length % 1024;
    bit_length_mod = 896 - bit_length_mod;
    bit_length_mod = (bit_length_mod + 1024) % 1024;

    string final_msg = hex_msg;
    final_msg += "8";
    bit_length_mod /= 4;
    for (int i = 0; i < bit_length_mod - 1; i++) {
        final_msg += "0";
    }

    stringstream ss;
    ss << hex << bit_length;
    string temp;
    ss >> temp;

    for (int i = 0; i < 32 - temp.length(); i++) 
        final_msg += "0";

    final_msg += temp;

    return final_msg;
}

string ROTR(string x, int k) {
    int size = x.length();
    for (int i = 0; i < k; i++) {
        char ch = x[x.length() - 1];
        x = ch + x;
        x = x.substr(0, size);
    }
    return x;
}

string SHR(string x, int k) {
    int size = x.length();
    for (int i = 0; i < k; i++) {
        x = "0" + x;
        x = x.substr(0, size);
    }
    return x;
}

string add_mod(string a, string b) {
    string c = "";
    int carry = 0;
    for (int i = a.length() - 1; i >= 0; i--) {
        char val1 = a[i] - '0', val2 = b[i] - '0';
        int sum = val1 + val2 + carry;
        if (sum % 2) {
            c = "1" + c;
        }
        else
            c = "0" + c;
        carry = sum / 2;
    }
    string ans = "";
    for (int i = c.length() - 64; i < c.length(); i++) {
        ans += c[i];
    }
    return ans;
}

string XOR(string a, string b) {
    string c = "";
    int i = 0, j = 0;
    while (i < a.length() || j < b.length()) {
        char ch1 = '0', ch2 = '0';
        if (i < a.length())
            ch1 = a[i];
        if (j < b.length())
            ch2 = b[j];
        i++;
        j++;
        if (ch1 == ch2)
            c += "0";
        else
            c += "1";
    }
    return c;
}

vector<string> get_msg_schedule(string final_msg) {
    vector<string> w(80);
    for (int i = 0; i <= 15; i++) {
        w[i] = final_msg.substr(i * 16, 16);
        w[i] = hex_to_binary(w[i]);
    }

    string temp = hex_to_binary(w[0]);

    for (int i = 16; i < 80; i++) {
        string s1, s2, s3, s4;
        string x = (w[i - 2]);
        string rotr19_x = ROTR(x, 19), rotr61_x = ROTR(x, 61), shr6_x = SHR(x, 6);
        s1 = XOR(rotr19_x, rotr61_x);
        s1 = XOR(s1, shr6_x);
        s2 = w[i - 7];
        x = (w[i - 15]);
        string rotr1_x = ROTR(x, 1), rotr8_x = ROTR(x, 8), shr7_x = SHR(x, 7);
        s3 = XOR(rotr1_x, rotr8_x);
        s3 = XOR(s3, shr7_x);
        s4 = w[i - 16];

        w[i] = add_mod(s1, s2);
        w[i] = add_mod(w[i], s3);
        w[i] = add_mod(w[i], s4);
    }

    return w;
}

string func_and(string a, string b) {
    string c = "";
    for (int i = 0; i < a.length(); i++) {
        if (a[i] == '1' && b[i] == '1')
            c += "1";
        else
            c += "0";
    }
    return c;
}

string func_not(string a) {
    string c = "";
    for (int i = 0; i < a.length(); i++) {
        if (a[i] == '0')
            c += "1";
        else
            c += "0";
    }
    return c;
}

string func_or(string a, string b) {
    string c = "";
    for (int i = 0; i < a.length(); i++) {
        if (a[i] == '1' || b[i] == '1')
            c += "1";
        else
            c += "0";
    }
    return c;
}

string func_ch(string e, string f, string g) {
    string t1 = func_and(e, f);
    string t2 = func_not(e);
    string t3 = func_and(t2, g);
    return XOR(t1, t3);
}

string func_maj(string a, string b, string c) {
    string t1 = func_and(a, b);
    string t2 = func_and(a, c);
    string t3 = func_and(b, c);

    string t4 = XOR(t1, t2);
    t4 = XOR(t4, t3);
    return t4;
}

string summasion0(string a) {
    string t1 = ROTR(a, 28), t2 = ROTR(a, 34), t3 = ROTR(a, 39);
    string ans = XOR(t1, t2);
    ans = XOR(ans, t3);
    return ans;
}
string summasion1(string e) {
    string t1 = ROTR(e, 14), t2 = ROTR(e, 18), t3 = ROTR(e, 41);
    string ans = XOR(t1, t2);
    ans = XOR(ans, t3);
    return ans;
}



string sha_algo(string final_msg) {


    for (int i = 0; i < 8; i++)
        H[i] = hex_to_binary(H[i]);
    for (int i = 0; i < 80; i++)
        k[i] = hex_to_binary(k[i]);

    for (int i = 0; i < final_msg.length(); i += 1024) {
        string str = final_msg.substr(i * 1024, 1024);
        vector<string> w = get_msg_schedule(str);
        string a = H[0], b = H[1], c = H[2], d = H[3], e = H[4], f = H[5], g = H[6], h = H[7];
        for (int j = 0; j < 80; j++) {
            string ch_efg = func_ch(e, f, g), maj_abc = func_maj(a, b, c), sum_0 = summasion0(a), sum_1 = summasion1(e);

            string t1 = add_mod(h, ch_efg);
            t1 = add_mod(t1, sum_1);
            t1 = add_mod(t1, w[j]);
            t1 = add_mod(t1, k[j]);

            string t2 = add_mod(sum_0, maj_abc);

            h = g;
            g = f;
            f = e;
            e = add_mod(d, t1);
            d = c;
            c = b;
            b = a;
            a = add_mod(t1, t2);
        }
        H[0] = add_mod(H[0], a);
        H[1] = add_mod(H[1], b);
        H[2] = add_mod(H[2], c);
        H[3] = add_mod(H[3], d);
        H[4] = add_mod(H[4], e);
        H[5] = add_mod(H[5], f);
        H[6] = add_mod(H[6], g);
        H[7] = add_mod(H[7], h);
    } kk

    string ans = "";
    for (int i = 0; i < 8; i++) {
        ans += binary_to_hex(H[i]);
    }
    return ans;
}


gmp_randstate_t state;
unsigned long seed;

void rand_init() {
    gmp_randinit_mt(state);
    seed = time(NULL);
    gmp_randseed_ui(state, seed);
}

void get_p_alpha(mpz_t p, mpz_t alpha, int bits) {
    mpz_t temp, q, r, t1, t2;
    int result = 0;
    mpz_inits(temp, q, r, t1, t2, NULL);
    while (!result) {
        int res1 = 0;
        while (!res1) {
            mpz_rrandomb(p, state, bits);
            res1 = mpz_probab_prime_p(p, 30);
        }
        mpz_sub_ui(temp, p, 1);
        mpz_fdiv_q_ui(temp, temp, 2);
        result = mpz_probab_prime_p(temp, 30);
        if (!result) {
            mpz_set_ui(q, 2);
            mpz_set(r, temp);
        }
    }


    int flag = 0;
    while (!flag) {
        mpz_urandomm(temp, state, p);
        while (mpz_cmp_ui(temp, 1) <= 0 || mpz_cmp(temp, p) >= 0) {
            mpz_urandomm(temp, state, p);
        }
        mpz_powm(t1, temp, q, p);
        mpz_powm(t2, temp, r, p);
        if (mpz_cmp_ui(t1, 1) != 0 && mpz_cmp_ui(t2, 1) != 0) {
            flag = 1;
        }
    }
    mpz_set(alpha, temp);
}

void get_public_private_key(mpz_t x, mpz_t y, mpz_t q, mpz_t alpha) {
    mpz_t temp, q_1;

    mpz_inits(temp, q_1, NULL);

    mpz_sub_ui(q_1, q, 1);
    mpz_urandomm(temp, state, q);
    while (mpz_cmp_ui(temp, 1) <= 0 || mpz_cmp(temp, q_1) >= 0) {
        mpz_urandomm(temp, state, q);
    }

    mpz_set(x, temp);
    mpz_powm(y, alpha, x, q);

}

void convert_hex_string_to_mpz_t(string m, mpz_t num) {
    mpz_set_ui(num, 0);
    for (int i = 0; i < m.length(); i++) {
        int val = ((m[i] >= '0' && m[i] <= '9') ? m[i] - '0' : m[i] - 'a' + 10);
        mpz_mul_ui(num, num, 16);
        mpz_add_ui(num, num, val);
    }
}

void GCD(mpz_t g, mpz_t A, mpz_t B) {
    if (mpz_cmp_ui(A, 0) == 0)
        mpz_set(g, B);
    else if (mpz_cmp_ui(B, 0) == 0)
        mpz_set(g, A);
    else {
        mpz_t a, b, t;
        mpz_inits(a, b, t, NULL);
        mpz_set(a, A);
        mpz_set(b, B);

        while (mpz_cmp_ui(b, 0)) {
            mpz_set(t, b);
            mpz_mod(b, a, b);
            mpz_set(a, t);
        }
        mpz_set(g, a);
    }
}


void get_sign_pair(mpz_t s1, mpz_t s2, mpz_t q, mpz_t m, mpz_t alpha, mpz_t xa) {
    mpz_t k, q_1, inv_k, temp, t1;
    mpz_inits(k, q_1, inv_k, temp, NULL);
    
    mpz_sub_ui(q_1, q, 1);
    
    mpz_set_ui(t1, 0);
    while (mpz_cmp_ui(t1, 1)) {
        mpz_urandomm(k, state, q);
        while (mpz_cmp_ui(k, 1) <= 0 && mpz_cmp(k, q_1) >= 0) {
            mpz_urandomm(k, state, q);
        }
        GCD(t1, k, q_1);
    }

    mpz_powm(s1, alpha, k, q);

    mpz_invert(inv_k, k, q_1);

    mpz_mul(temp, xa, s1);
    mpz_sub(temp, m, temp);
    mpz_mod(temp, temp, q_1);

    mpz_mul(temp, inv_k, temp);
    mpz_mod(temp, temp, q_1);
    mpz_set(s2, temp);


}

bool verifying_sign_pair(mpz_t s1, mpz_t s2, mpz_t ya, mpz_t alpha, mpz_t m, mpz_t q) {
    mpz_t v1, v2, temp;
    mpz_inits(v1, v2, NULL);


    mpz_powm(v1, alpha, m, q);

    mpz_powm(temp, s1, s2, q);
    mpz_powm(v2, ya, s1, q);

    mpz_mul(v2, v2, temp);
    mpz_mod(v2, v2, q);

    return mpz_cmp(v1, v2) == 0;
}


int main() {

    rand_init();

    cout << "Enter the string: ";
    getline(cin, msg);



    string final_msg = get_Message(msg);
    string h_m = sha_algo(final_msg);
    // printf("hash value: %s\n", h_m);
    cout << "Hash value : " << h_m << endl;


    mpz_t m, q, alpha, xa, ya, s1, s2;
    int bits = 1024;

    mpz_inits(m, q, alpha, xa, ya, s1, s2, NULL);

    convert_hex_string_to_mpz_t(h_m, m);


    // get_p_alpha(q, alpha, bits);
    get_p_alpha(q, alpha, bits);

    gmp_printf("\nq : %Zd\n\nalpha : %Zd\n\n", q, alpha);

    // USER A generates public key and private key
    get_public_private_key(xa, ya, q, alpha);


    // getting signature pair
    get_sign_pair(s1, s2, q, m, alpha, xa);

    gmp_printf("S1: %Zd\nS2: %Zd\n", s1, s2);

    if (verifying_sign_pair(s1, s2, ya, alpha, m, q)) {
        printf("Signature verified\n");
    }
    else {
        printf("Signature not verified\n");
    }

    return 0;
}

































//sha 512
#include <bits/stdc++.h>
#include <gmp.h>

using namespace std;


string msg, hex_msg;
vector<string> w;

vector<string> k = {
    "428a2f98d728ae22", "7137449123ef65cd", "b5c0fbcfec4d3b2f", "e9b5dba58189dbbc",
    "3956c25bf348b538", "59f111f1b605d019", "923f82a4af194f9b", "ab1c5ed5da6d8118",
    "d807aa98a3030242", "12835b0145706fbe", "243185be4ee4b28c", "550c7dc3d5ffb4e2",
    "72be5d74f27b896f", "80deb1fe3b1696b1", "9bdc06a725c71235", "c19bf174cf692694",
    "e49b69c19ef14ad2", "efbe4786384f25e3", "0fc19dc68b8cd5b5", "240ca1cc77ac9c65",
    "2de92c6f592b0275", "4a7484aa6ea6e483", "5cb0a9dcbd41fbd4", "76f988da831153b5",
    "983e5152ee66dfab", "a831c66d2db43210", "b00327c898fb213f", "bf597fc7beef0ee4",
    "c6e00bf33da88fc2", "d5a79147930aa725", "06ca6351e003826f", "142929670a0e6e70",
    "27b70a8546d22ffc", "2e1b21385c26c926", "4d2c6dfc5ac42aed", "53380d139d95b3df",
    "650a73548baf63de", "766a0abb3c77b2a8", "81c2c92e47edaee6", "92722c851482353b",
    "a2bfe8a14cf10364", "a81a664bbc423001", "c24b8b70d0f89791", "c76c51a30654be30",
    "d192e819d6ef5218", "d69906245565a910", "f40e35855771202a", "106aa07032bbd1b8",
    "19a4c116b8d2d0c8", "1e376c085141ab53", "2748774cdf8eeb99", "34b0bcb5e19b48a8",
    "391c0cb3c5c95a63", "4ed8aa4ae3418acb", "5b9cca4f7763e373", "682e6ff3d6b2b8a3",
    "748f82ee5defb2fc", "78a5636f43172f60", "84c87814a1f0ab72", "8cc702081a6439ec",
    "90befffa23631e28", "a4506cebde82bde9", "bef9a3f7b2c67915", "c67178f2e372532b",
    "ca273eceea26619c", "d186b8c721c0c207", "eada7dd6cde0eb1e", "f57d4f7fee6ed178",
    "06f067aa72176fba", "0a637dc5a2c898a6", "113f9804bef90dae", "1b710b35131c471b",
    "28db77f523047d84", "32caab7b40c72493", "3c9ebe0a15c9bebc", "431d67c49c100d4c",
    "4cc5d4becb3e42b6", "597f299cfc657e2a", "5fcb6fab3ad6faec", "6c44198c4a475817"
    
};


vector<string> H = {
    "6a09e667f3bcc908", "bb67ae8584caa73b", "3c6ef372fe94f82b", "a54ff53a5f1d36f1", 
    "510e527fade682d1", "9b05688c2b3e6c1f", "1f83d9abfb41bd6b", "5be0cd19137e2179"
};


string get_str_to_hex(string str) {
    string ans = "";
    for (int i = 0; i < str.length(); i++) {
        stringstream ss;
        ss << hex << (int)(str[i]);
        string temp;
        ss >> temp;
        ans += temp;
    }
    return ans;
}


string hex_to_binary(string str) {
    string ans = "";
    for (int i = 0; i < str.length(); i++) {
        int num = ((str[i] >= '0' && str[i] <= '9') ? (str[i] - '0') : (str[i] - 'a' + 10));
        string temp = "";
        for (int j = 0; j < 4; j++) {
            if (num % 2)
                temp = "1" + temp;
            else
                temp = "0" + temp;
            num /= 2;
        }
        ans += temp;
    }
    return ans;
}

string binary_to_hex(string str) {
    string ans = "";
    for (int i = 0; i < str.length(); i += 4) {
        int val = 0;
        for (int j = 0; j < 4; j++) {
            int temp = (str[i + j] == '1' ? 1 : 0);
            val = (val * 2) + temp;
        }
        char ch;
        if (val <= 9)
            ch = '0' + val;
        else
            ch = 'a' + (val - 10);
        ans += ch;
    }
    return ans;
}

string get_Message(string msg) {
    hex_msg = get_str_to_hex(msg);

    int bit_length = msg.length() * 8;

    int bit_length_mod = bit_length % 1024;
    bit_length_mod = 896 - bit_length_mod;
    bit_length_mod = (bit_length_mod + 1024) % 1024;

    string final_msg = hex_msg;
    final_msg += "8";
    bit_length_mod /= 4;
    for (int i = 0; i < bit_length_mod - 1; i++) {
        final_msg += "0";
    }

    stringstream ss;
    ss << hex << bit_length;
    string temp;
    ss >> temp;

    for (int i = 0; i < 32 - temp.length(); i++) 
        final_msg += "0";

    final_msg += temp;

    return final_msg;
}

string ROTR(string x, int k) {
    int size = x.length();
    for (int i = 0; i < k; i++) {
        char ch = x[x.length() - 1];
        x = ch + x;
        x = x.substr(0, size);
    }
    return x;
}

string SHR(string x, int k) {
    int size = x.length();
    for (int i = 0; i < k; i++) {
        x = "0" + x;
        x = x.substr(0, size);
    }
    return x;
}

string add_mod(string a, string b) {
    string c = "";
    int carry = 0;
    for (int i = a.length() - 1; i >= 0; i--) {
        char val1 = a[i] - '0', val2 = b[i] - '0';
        int sum = val1 + val2 + carry;
        if (sum % 2) {
            c = "1" + c;
        }
        else
            c = "0" + c;
        carry = sum / 2;
    }
    string ans = "";
    for (int i = c.length() - 64; i < c.length(); i++) {
        ans += c[i];
    }
    return ans;
}

string XOR(string a, string b) {
    string c = "";
    int i = 0, j = 0;
    while (i < a.length() || j < b.length()) {
        char ch1 = '0', ch2 = '0';
        if (i < a.length())
            ch1 = a[i];
        if (j < b.length())
            ch2 = b[j];
        i++;
        j++;
        if (ch1 == ch2)
            c += "0";
        else
            c += "1";
    }
    return c;
}

vector<string> get_msg_schedule(string final_msg) {
    vector<string> w(80);
    for (int i = 0; i <= 15; i++) {
        w[i] = final_msg.substr(i * 16, 16);
        w[i] = hex_to_binary(w[i]);
    }

    string temp = hex_to_binary(w[0]);

    for (int i = 16; i < 80; i++) {
        string s1, s2, s3, s4;
        string x = (w[i - 2]);
        string rotr19_x = ROTR(x, 19), rotr61_x = ROTR(x, 61), shr6_x = SHR(x, 6);
        s1 = XOR(rotr19_x, rotr61_x);
        s1 = XOR(s1, shr6_x);
        s2 = w[i - 7];
        x = (w[i - 15]);
        string rotr1_x = ROTR(x, 1), rotr8_x = ROTR(x, 8), shr7_x = SHR(x, 7);
        s3 = XOR(rotr1_x, rotr8_x);
        s3 = XOR(s3, shr7_x);
        s4 = w[i - 16];

        w[i] = add_mod(s1, s2);
        w[i] = add_mod(w[i], s3);
        w[i] = add_mod(w[i], s4);
    }

    return w;
}

string func_and(string a, string b) {
    string c = "";
    for (int i = 0; i < a.length(); i++) {
        if (a[i] == '1' && b[i] == '1')
            c += "1";
        else
            c += "0";
    }
    return c;
}

string func_not(string a) {
    string c = "";
    for (int i = 0; i < a.length(); i++) {
        if (a[i] == '0')
            c += "1";
        else
            c += "0";
    }
    return c;
}

string func_or(string a, string b) {
    string c = "";
    for (int i = 0; i < a.length(); i++) {
        if (a[i] == '1' || b[i] == '1')
            c += "1";
        else
            c += "0";
    }
    return c;
}

string func_ch(string e, string f, string g) {
    string t1 = func_and(e, f);
    string t2 = func_not(e);
    string t3 = func_and(t2, g);
    return XOR(t1, t3);
}

string func_maj(string a, string b, string c) {
    string t1 = func_and(a, b);
    string t2 = func_and(a, c);
    string t3 = func_and(b, c);

    string t4 = XOR(t1, t2);
    t4 = XOR(t4, t3);
    return t4;
}

string summasion0(string a) {
    string t1 = ROTR(a, 28), t2 = ROTR(a, 34), t3 = ROTR(a, 39);
    string ans = XOR(t1, t2);
    ans = XOR(ans, t3);
    return ans;
}
string summasion1(string e) {
    string t1 = ROTR(e, 14), t2 = ROTR(e, 18), t3 = ROTR(e, 41);
    string ans = XOR(t1, t2);
    ans = XOR(ans, t3);
    return ans;
}



string sha_algo(string final_msg) {


    for (int i = 0; i < 8; i++)
        H[i] = hex_to_binary(H[i]);
    for (int i = 0; i < 80; i++)
        k[i] = hex_to_binary(k[i]);

    for (int i = 0; i < final_msg.length(); i += 1024) {
        string str = final_msg.substr(i * 1024, 1024);
        vector<string> w = get_msg_schedule(str);
        string a = H[0], b = H[1], c = H[2], d = H[3], e = H[4], f = H[5], g = H[6], h = H[7];
        for (int j = 0; j < 80; j++) {
            string ch_efg = func_ch(e, f, g), maj_abc = func_maj(a, b, c), sum_0 = summasion0(a), sum_1 = summasion1(e);

            string t1 = add_mod(h, ch_efg);
            t1 = add_mod(t1, sum_1);
            t1 = add_mod(t1, w[j]);
            t1 = add_mod(t1, k[j]);

            string t2 = add_mod(sum_0, maj_abc);

            h = g;
            g = f;
            f = e;
            e = add_mod(d, t1);
            d = c;
            c = b;
            b = a;
            a = add_mod(t1, t2);
        }
        H[0] = add_mod(H[0], a);
        H[1] = add_mod(H[1], b);
        H[2] = add_mod(H[2], c);
        H[3] = add_mod(H[3], d);
        H[4] = add_mod(H[4], e);
        H[5] = add_mod(H[5], f);
        H[6] = add_mod(H[6], g);
        H[7] = add_mod(H[7], h);
    }

    string ans = "";
    for (int i = 0; i < 8; i++) {
        ans += binary_to_hex(H[i]);
    }
    return ans;
}

int main() {

    cout << "Enter the string: ";

    getline(cin, msg);

    string final_msg = get_Message(msg);


    string final_hash = sha_algo(final_msg);
    cout << "Hash Value: " << final_hash << endl;

    return 0;
}










//des


#include <iostream>
#include <string>
#include <cmath>
using namespace std;
string round_keys[16];
string pt, key;
string convertDecimalToBinary(int decimal)
{
	string binary;
    while(decimal != 0) {
		binary = (decimal % 2 == 0 ? "0" : "1") + binary; 
		decimal = decimal/2;
	}
	while(binary.length() < 4){
		binary = "0" + binary;
	}
    return binary;
}
int convertBinaryToDecimal(string binary)
{
    int decimal = 0;
	int counter = 0;
	int size = binary.length();
	for(int i = size-1; i >= 0; i--)
	{
    	if(binary[i] == '1'){
        	decimal += pow(2, counter);
    	}
    counter++;
	}
	return decimal;
}
string shift_left_once(string key_chunk){ 
    string shifted="";  
        for(int i = 1; i < 28; i++){ 
            shifted += key_chunk[i]; 
        } 
        shifted += key_chunk[0];   
    return shifted; 
} 
string shift_left_twice(string key_chunk){ 
    string shifted=""; 
    for(int i = 0; i < 2; i++){ 
        for(int j = 1; j < 28; j++){ 
            shifted += key_chunk[j]; 
        } 
        shifted += key_chunk[0]; 
        key_chunk= shifted; 
        shifted =""; 
    } 
    return key_chunk; 
}
string Xor(string a, string b){ 
	string result = ""; 
	int size = b.size();
	for(int i = 0; i < size; i++){ 
		if(a[i] != b[i]){ 
			result += "1"; 
		}
		else{ 
			result += "0"; 
		} 
	} 
	return result; 
} 
void generate_keys(string key){
	int pc1[56] = {
	57,49,41,33,25,17,9, 
	1,58,50,42,34,26,18, 
	10,2,59,51,43,35,27, 
	19,11,3,60,52,44,36,		 
	63,55,47,39,31,23,15, 
	7,62,54,46,38,30,22, 
	14,6,61,53,45,37,29, 
	21,13,5,28,20,12,4 
	};
	int pc2[48] = { 
	14,17,11,24,1,5, 
	3,28,15,6,21,10, 
	23,19,12,4,26,8, 
	16,7,27,20,13,2, 
	41,52,31,37,47,55, 
	30,40,51,45,33,48, 
	44,49,39,56,34,53, 
	46,42,50,36,29,32 
	}; 
	string perm_key =""; 
	for(int i = 0; i < 56; i++){ 
		perm_key+= key[pc1[i]-1]; 
	} 
	string left= perm_key.substr(0, 28); 
	string right= perm_key.substr(28, 28); 
	for(int i=0; i<16; i++){ 
		if(i == 0 || i == 1 || i==8 || i==15 ){
			left= shift_left_once(left); 
			right= shift_left_once(right);
		} 
		else{
			left= shift_left_twice(left); 
			right= shift_left_twice(right);
		}
		string combined_key = left + right;
		string round_key = ""; 
		for(int i = 0; i < 48; i++){ 
			round_key += combined_key[pc2[i]-1]; 
		}   
		round_keys[i] = round_key; 
	} 

}
string DES(){ 
	int initial_permutation[64] = { 
	58,50,42,34,26,18,10,2, 
	60,52,44,36,28,20,12,4, 
	62,54,46,38,30,22,14,6, 
	64,56,48,40,32,24,16,8, 
	57,49,41,33,25,17,9,1, 
	59,51,43,35,27,19,11,3, 
	61,53,45,37,29,21,13,5, 
	63,55,47,39,31,23,15,7 
	}; 
	int expansion_table[48] = { 
	32,1,2,3,4,5,4,5, 
	6,7,8,9,8,9,10,11, 
	12,13,12,13,14,15,16,17, 
	16,17,18,19,20,21,20,21, 
	22,23,24,25,24,25,26,27, 
	28,29,28,29,30,31,32,1 
	}; 
	int substition_boxes[8][4][16]=  
	{{ 
        14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7, 
        0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8, 
        4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0, 
        15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13 
    }, 
    { 
        15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10, 
        3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5, 
        0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15, 
        13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9 
    }, 
    { 
        10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8, 
        13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1, 
        13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7, 
        1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12 
    }, 
    { 
        7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15, 
        13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9, 
        10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4, 
        3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14 
    }, 
    { 
        2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9, 
        14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6, 
        4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14, 
        11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3 
    }, 
    { 
        12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11, 
        10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8, 
        9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6, 
        4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13 
    }, 
    { 
        4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1, 
        13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6, 
        1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2, 
        6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12 
    }, 
    { 
        13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7, 
        1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2, 
        7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8, 
        2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11 
    }};
	int permutation_tab[32] = { 
	16,7,20,21,29,12,28,17, 
	1,15,23,26,5,18,31,10, 
	2,8,24,14,32,27,3,9,
	19,13,30,6,22,11,4,25 
	}; 
	int inverse_permutation[64]= { 
	40,8,48,16,56,24,64,32, 
	39,7,47,15,55,23,63,31, 
	38,6,46,14,54,22,62,30, 
	37,5,45,13,53,21,61,29, 
	36,4,44,12,52,20,60,28, 
	35,3,43,11,51,19,59,27, 
	34,2,42,10,50,18,58,26, 
	33,1,41,9,49,17,57,25 
	};
  	string perm = ""; 
	for(int i = 0; i < 64; i++){ 
		perm += pt[initial_permutation[i]-1]; 
	}  
	string left = perm.substr(0, 32); 
	string right = perm.substr(32, 32); 
	for(int i=0; i<16; i++) { 
    	string right_expanded = ""; 
		
    	for(int i = 0; i < 48; i++) { 
      		right_expanded += right[expansion_table[i]-1]; 
    };  
		string xored = Xor(round_keys[i], right_expanded);  
		string res = ""; 
		
		for(int i=0;i<8; i++){ 
			
      		string row1= xored.substr(i*6,1) + xored.substr(i*6 + 5,1);
      		int row = convertBinaryToDecimal(row1);
      		string col1 = xored.substr(i*6 + 1,1) + xored.substr(i*6 + 2,1) + xored.substr(i*6 + 3,1) + xored.substr(i*6 + 4,1);;
			int col = convertBinaryToDecimal(col1);
			int val = substition_boxes[i][row][col];
			res += convertDecimalToBinary(val);  
		} 
		
		string perm2 =""; 
		for(int i = 0; i < 32; i++){ 
			perm2 += res[permutation_tab[i]-1]; 
		}
		
		xored = Xor(perm2, left);
		
		left = xored; 
		if(i < 15){ 
			string temp = right;
			right = xored;
			left = temp;
		} 
	} 
	
	string combined_text = left + right;   
	string ciphertext =""; 
	
	for(int i = 0; i < 64; i++){ 
		ciphertext+= combined_text[inverse_permutation[i]-1]; 
	}
	
	return ciphertext; 
}
int main(){ 
	cout << "Enter the 64-bit key: ";
	cin >> key;
	cout << "Enter the plain text: ";
	cin >> pt;
	string apt = pt;
  	generate_keys(key); 
    cout<<"Plain text: "<<pt<<endl; 

    string ct= DES(); 
    cout<<"Ciphertext: "<<ct<<endl;
	int i = 15;
	int j = 0;
	while(i > j)
	{
		string temp = round_keys[i];
		round_keys[i] = round_keys[j];
		round_keys[j] = temp;
		i--;
		j++;
	}
	pt = ct;
	string decrypted = DES();
	cout<<"Decrypted text:"<<decrypted<<endl;
	if (decrypted == apt){
		cout<<"Plain text encrypted and decrypted successfully."<<endl;
	}
	else{
		cout << "Decryption failed" << endl;
	}
	return 0;
	
} 








//rsa


#include <bits/stdc++.h>
#include <gmp.h>

using namespace std;


gmp_randstate_t state;
unsigned int seed;
void Rand_init() {
	gmp_randinit_mt(state);
	seed = time(NULL);
	gmp_randseed_ui(state, seed);
}



int main () {

	Rand_init();

	mpz_t p, q, n, count, totient, e, d, pt, ct, dt, temp;
	mpz_inits(p, q, n, count, totient, e, d, pt, ct, dt, temp, NULL);
	
	int bits = 16, result = 0;
	while (!result) {
		mpz_rrandomb(p, state, bits);
		result = mpz_probab_prime_p(p, 1000);
	}
	result = 0;
	while (!result) {
		mpz_rrandomb(q, state, bits);
		result = mpz_probab_prime_p(q, 1000);
	}
	gmp_printf("p: %Zd\nq: %Zd\n", p, q);
	
	mpz_mul(n, p, q);
	
	mpz_sub_ui(p, p, 1);
	mpz_sub_ui(q, q, 1);
	mpz_mul(totient, p, q);
	mpz_add_ui(p, p, 1);
	mpz_add_ui(q, q, 1);
	
	
	gmp_printf("n: %Zd\ntotient: %Zd\n", n, totient);
	
	while (mpz_cmp_ui(e, 1) <= 0 || mpz_cmp_ui(temp, 1) != 0) {
		mpz_urandomm(e, state, totient);
		mpz_gcd(temp, e, totient);
	}
	
	gmp_printf("e: %Zd\n", e);
	
	mpz_invert(d, e, totient);
	gmp_printf("d: %Zd\n", d);
	mpz_mul(temp, e, d);
	mpz_mod(temp, temp, totient);
	
	printf("Enter the Message: ");
	gmp_scanf("%Zd", pt);
	
	mpz_powm(ct, pt, e, n);
	
	gmp_printf("CipherText: %Zd\n", ct);
	
	mpz_powm(dt, ct, d, n);
	gmp_printf("Decrypted Text: %Zd\n", dt);
	
	if (mpz_cmp(pt, dt) == 0) {
		printf("Decryption successful\n");
	}
	else {
		printf("Decryption failed\n");
	}
	
	return 0;
}















//deffie-helmann
#include <bits/stdc++.h>
#include <gmp.h>

using namespace std;

gmp_randstate_t state;
unsigned long seed;

void rand_init() {
    gmp_randinit_mt(state);
    seed = time(NULL);
    gmp_randseed_ui(state, seed);
}

void get_p_q_r_alpha(mpz_t p, mpz_t alpha, int bits) {
    mpz_t temp, q, r, t1, t2;
    int result = 0;
    mpz_inits(temp, q, r, t1, t2, NULL);
    while (!result) {
        int res1 = 0;
        while (!res1) {
            mpz_rrandomb(p, state, bits);
            res1 = mpz_probab_prime_p(p, 30);
        }
        mpz_sub_ui(temp, p, 1);
        mpz_fdiv_q_ui(temp, temp, 2);
        result = mpz_probab_prime_p(temp, 30);
        if (!result) {
            mpz_set_ui(q, 2);
            mpz_set(r, temp);
        }
    }


    int flag = 0;
    while (!flag) {
        mpz_urandomm(temp, state, p);
        while (mpz_cmp_ui(temp, 1) <= 0 || mpz_cmp(temp, p) >= 0) {
            mpz_urandomm(temp, state, p);
        }
        mpz_powm(t1, temp, q, p);
        mpz_powm(t2, temp, r, p);
        if (mpz_cmp_ui(t1, 1) != 0 && mpz_cmp_ui(t2, 1) != 0) {
            flag = 1;
        }
    }
    mpz_set(alpha, temp);
}

void secret_key_generation(mpz_t k, mpz_t y, mpz_t x, mpz_t q) {
    mpz_powm(k, y, x, q);
}



int main() {

    rand_init();

    int bits = 1024;

    mpz_t p, q, r, alpha, xa, xb, ya, yb, ka, kb;
    mpz_inits(p, q, r, alpha, xa, xb, ya, yb, ka, kb, NULL);

    get_p_q_r_alpha(p, alpha, bits);

    gmp_printf("Prime Number\n%Zd\ngenertor is\n%Zd\n", p, alpha);

    // user A key generation
    mpz_urandomm(xa, state, p);
    while (mpz_cmp_ui(xa, 1) <= 0 || mpz_cmp(xa, p) >= 0) {
        mpz_urandomm(xa, state, p);
    }

    mpz_set_ui(xa, 97);
    mpz_powm(ya, alpha, xa, p);

    //user B key generation
    mpz_urandomm(xb, state, p);
    while (mpz_cmp_ui(xb, 1) <= 0 || mpz_cmp(xb, p) >= 0) {
        mpz_urandomm(xb, state, p);
    }

    mpz_powm(yb, alpha, xb, p);

    gmp_printf("User A public key\n%Zd\nUser B public key\n%Zd\n", ya, yb);


    // generation of secret key by user A
    mpz_powm(ka, yb, xa, p);

    // generation of secret key by user B
    mpz_powm(kb, ya, xb, p);
    
    if (mpz_cmp(ka, kb))
        printf("Secret keys generated does not match.\n");
    else
        printf("Secret keys generated are matched\n");

    return 0;
}




















//elgamal 
#include <bits/stdc++.h>
#include <gmp.h>

using namespace std;

gmp_randstate_t state;
unsigned long seed;

void rand_init(){
	gmp_randinit_mt(state);
	seed = time(NULL);
	gmp_randseed_ui(state, seed);
}

void get_p_alpha(mpz_t p, mpz_t alpha) {
	int bits = 1024, flag = 0;
	mpz_t t1, t2, t3, q, r;
	mpz_inits(t1, t2, t3, q, r, NULL);
	while (!flag) {
		int f = 0;
		while (!f) {
			mpz_rrandomb(p, state, bits);
			f = mpz_probab_prime_p(p, 30);
		}
		mpz_sub_ui(t1, p, 1);
		mpz_fdiv_q_ui(t1, t1, 2);
		flag = mpz_probab_prime_p(t1, 30);
	}
	mpz_set_ui(q, 2);
	mpz_set(r, t1);
	
	flag = 0;
	while (!flag) {
		mpz_urandomm(t1, state, p);
		while (mpz_cmp_ui(t1, 1) <= 0 || mpz_cmp(t1, p) >= 0) {
			mpz_urandomm(t1, state, p);
		}
		mpz_powm(t2, t1, q, p);
		mpz_powm(t3, t1, r, p);
		if (mpz_cmp_ui(t2, 1) != 0 && mpz_cmp_ui(t3, 1) != 0) {
			mpz_set(alpha, t1);
			flag = 1;
		}
	}
}

int main() {
	
	rand_init();
	
	mpz_t p, g, x1, y1, k, m, c1, c2, temp;
	
	mpz_inits(p, g, x1, y1, k, m, c1, c2, temp, NULL);
	
	get_p_alpha(p, g);

	gmp_printf("prime Number: %Zd\n\nalpha: %Zd\n\n", p, g);
	
	mpz_urandomm(x1, state, p);
	mpz_sub_ui(temp, p, 1);
	
	while (mpz_cmp_ui(k, 1) <= 0 || mpz_cmp(k, temp) >= 0) {
		mpz_urandomm(k, state, p);
	}
	
	
	// private key
	while (mpz_cmp_ui(x1, 1) <= 0 || mpz_cmp(x1, temp) >= 0) {
		mpz_urandomm(x1, state, p);
	}
	// public key
	mpz_powm(y1, g, x1, p);
	

	printf("Enter message: ");
	gmp_scanf("%Zd", m);
	
	// C1 and C2
	mpz_powm(c1, g, k, p);
	mpz_powm(c2, y1, k, p);
	mpz_mul(c2, c2, m);
	mpz_mod(c2, c2, p);
	
	gmp_printf("C1: %Zd\n\nC2: %Zd\n\n", c1, c2);
	
	
	mpz_powm(c1, c1, x1, p);
	mpz_invert(c1, c1, p);
	mpz_mul(c2, c2, c1);
	mpz_mod(c2, c2, p);
	
	gmp_printf("decrypted text: %Zd\n\n", c2);
	
	if (mpz_cmp(m, c2) == 0) {
		printf("decryption successful\n");
	}
	else {
		printf("decryption failed\n");
	}
	
	
	return 0;
}























































//aes
#include <iostream>
#include <stdlib.h>
#include <string.h>
#include <cstring>
#include <unistd.h>
#include <stdio.h>
#include <bits/stdc++.h>
#include "aesHeaders.h"

using namespace std;


unsigned char key[] = "aAbBcCdDeEfFgGhH";

void AddRoundKey(unsigned char * state, unsigned char * roundKey) {
	for (int i = 0; i < 16; i++) {
		state[i] ^= roundKey[i];
	}
}

void SubBytes(unsigned char * state) {
	for (int i = 0; i < 16; i++) {
		state[i] = s[state[i]];
	}
}


void ShiftRows(unsigned char * state) {
	unsigned char tmp[16];

	/* Column 1 */
	tmp[0] = state[0];
	tmp[1] = state[5];
	tmp[2] = state[10];
	tmp[3] = state[15];
	
	/* Column 2 */
	tmp[4] = state[4];
	tmp[5] = state[9];
	tmp[6] = state[14];
	tmp[7] = state[3];

	/* Column 3 */
	tmp[8] = state[8];
	tmp[9] = state[13];
	tmp[10] = state[2];
	tmp[11] = state[7];
	
	/* Column 4 */
	tmp[12] = state[12];
	tmp[13] = state[1];
	tmp[14] = state[6];
	tmp[15] = state[11];

	for (int i = 0; i < 16; i++)
		state[i] = tmp[i];
	
}

void MixColumns(unsigned char * state) {
	unsigned char tmp[16];

	tmp[0] = (unsigned char) mul2[state[0]] ^ mul3[state[1]] ^ state[2] ^ state[3];
	tmp[1] = (unsigned char) state[0] ^ mul2[state[1]] ^ mul3[state[2]] ^ state[3];
	tmp[2] = (unsigned char) state[0] ^ state[1] ^ mul2[state[2]] ^ mul3[state[3]];
	tmp[3] = (unsigned char) mul3[state[0]] ^ state[1] ^ state[2] ^ mul2[state[3]];

	tmp[4] = (unsigned char)mul2[state[4]] ^ mul3[state[5]] ^ state[6] ^ state[7];
	tmp[5] = (unsigned char)state[4] ^ mul2[state[5]] ^ mul3[state[6]] ^ state[7];
	tmp[6] = (unsigned char)state[4] ^ state[5] ^ mul2[state[6]] ^ mul3[state[7]];
	tmp[7] = (unsigned char)mul3[state[4]] ^ state[5] ^ state[6] ^ mul2[state[7]];

	tmp[8] = (unsigned char)mul2[state[8]] ^ mul3[state[9]] ^ state[10] ^ state[11];
	tmp[9] = (unsigned char)state[8] ^ mul2[state[9]] ^ mul3[state[10]] ^ state[11];
	tmp[10] = (unsigned char)state[8] ^ state[9] ^ mul2[state[10]] ^ mul3[state[11]];
	tmp[11] = (unsigned char)mul3[state[8]] ^ state[9] ^ state[10] ^ mul2[state[11]];

	tmp[12] = (unsigned char)mul2[state[12]] ^ mul3[state[13]] ^ state[14] ^ state[15];
	tmp[13] = (unsigned char)state[12] ^ mul2[state[13]] ^ mul3[state[14]] ^ state[15];
	tmp[14] = (unsigned char)state[12] ^ state[13] ^ mul2[state[14]] ^ mul3[state[15]];
	tmp[15] = (unsigned char)mul3[state[12]] ^ state[13] ^ state[14] ^ mul2[state[15]];

	for (int i = 0; i < 16; i++)
		state[i] = tmp[i];
	
}

void encryptionRound(unsigned char * state, unsigned char * key) {
	SubBytes(state);
	ShiftRows(state);
	MixColumns(state);
	AddRoundKey(state, key);
}


void finalRound(unsigned char * state, unsigned char * key) {
	SubBytes(state);
	ShiftRows(state);
	AddRoundKey(state, key);
}

void AESEncrypt(unsigned char * message, unsigned char * expandedKey, unsigned char * encryptedMessage) {
	
	unsigned char state[16]; 

	for (int i = 0; i < 16; i++)
		state[i] = message[i];
	

	int numberOfRounds = 9;

	AddRoundKey(state, expandedKey); // Initial round

	for (int i = 0; i < numberOfRounds; i++) {
		encryptionRound(state, expandedKey + (16 * (i+1)));
	}

	finalRound(state, expandedKey + 160);


	for (int i = 0; i < 16; i++)
		encryptedMessage[i] = state[i];
	
}

int main(){

	unsigned char expandedKey[176];

	KeyExpansion(key, expandedKey);


	while(1){
		cout<<"Enter message (exactly 16 characters) = ";
		char msg[17];
		cin.getline(msg, sizeof(msg));

		
		unsigned char *msgIn = new unsigned char[16];
		
		for(int i=0;i<16;i++)
			msgIn[i] = msg[i];
		
		
		unsigned char encryptedMsg[17];
		AESEncrypt(msgIn,expandedKey,encryptedMsg);
		
		encryptedMsg[16]='\0';
		cout<<"Final Encrypted Message = "<<encryptedMsg<<"\n";
		
	}
	return 0;
}		



//aesHeaders.h
#ifndef STRUCTURES_H
#define STRUCTURES_H

// Encryption: Forward Rijndael S-box 
unsigned char s[256] =
{
	0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
	0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
	0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
	0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
	0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
	0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
	0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
	0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
	0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
	0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
	0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
	0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
	0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
	0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
	0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
	0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
};

// Encryption: Multiply by 2 for MixColumns
unsigned char mul2[] =
{
	0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
	0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
	0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
	0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
	0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
	0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
	0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
	0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
	0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
	0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
	0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
	0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
	0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
	0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
	0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
	0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5
};

// Encryption: Multiply by 3 for MixColumns
unsigned char mul3[] =
{
	0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
	0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
	0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
	0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
	0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
	0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
	0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
	0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
	0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
	0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
	0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
	0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
	0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
	0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
	0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
	0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a
};

// Used in KeyExpansion
unsigned char rcon[256] = {
	0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
	0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
	0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
	0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
	0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
	0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
	0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
	0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
	0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
	0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
	0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
	0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
	0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
	0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
	0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
	0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
};

// Decryption: Inverse Rijndael S-box
unsigned char inv_s[256] =
{
	0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
	0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
	0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
	0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
	0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
	0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
	0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
	0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
	0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
	0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
	0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
	0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
	0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
	0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
	0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
};

// Decryption: Multiply by 9 for InverseMixColumns
unsigned char mul9[256] =
{
	0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
	0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
	0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
	0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
	0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
	0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
	0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
	0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,
	0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,
	0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
	0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
	0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
	0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
	0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,
	0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
	0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46
};

// Decryption: Multiply by 11 for InverseMixColumns
unsigned char mul11[256] =
{
	0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
	0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
	0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
	0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
	0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
	0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
	0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
	0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
	0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
	0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
	0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
	0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
	0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
	0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
	0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
	0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3
};

// Decryption: Multiply by 13 for InverseMixColumns
unsigned char mul13[256] =
{
	0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
	0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
	0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
	0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
	0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
	0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
	0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
	0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
	0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
	0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
	0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
	0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
	0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
	0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
	0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
	0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97
};

// Decryption: Multiply by 14 for InverseMixColumns
unsigned char mul14[256] =
{
	0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
	0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
	0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
	0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
	0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
	0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
	0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
	0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
	0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
	0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
	0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
	0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
	0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
	0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
	0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
	0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d
};

void KeyExpansionCore(unsigned char * in, unsigned char i) {
	
	unsigned char t = in[0];
	in[0] = in[1];
	in[1] = in[2];
	in[2] = in[3];
	in[3] = t;

	
	in[0] = s[in[0]];
	in[1] = s[in[1]];
	in[2] = s[in[2]];
	in[3] = s[in[3]];

	in[0] ^= rcon[i];
}


void KeyExpansion(unsigned char inputKey[16], unsigned char expandedKeys[176]) {
	
	for (int i = 0; i < 16; i++) {
		expandedKeys[i] = inputKey[i];
	}

	int bytesGenerated = 16; 
	int rconIteration = 1; 
	unsigned char tmpCore[4]; 

	while (bytesGenerated < 176) {
		
		for (int i = 0; i < 4; i++)
			tmpCore[i] = expandedKeys[i + bytesGenerated - 4];

		
		if (bytesGenerated % 16 == 0) 
			KeyExpansionCore(tmpCore, rconIteration++);
		
		for (unsigned char a = 0; a < 4; a++) {
			expandedKeys[bytesGenerated] = expandedKeys[bytesGenerated - 16] ^ tmpCore[a];
			bytesGenerated++;
		}

	}
}

#endif /* STRUCTURES_H */






